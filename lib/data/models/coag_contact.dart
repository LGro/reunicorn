// Copyright 2024 - 2026 The Reunicorn Authors. All rights reserved.
// SPDX-License-Identifier: AGPL-3.0-or-later

import 'dart:convert';
import 'dart:typed_data';

import 'package:equatable/equatable.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:veilid/veilid.dart';

import 'contact_details.dart';
import 'contact_introduction.dart';
import 'contact_location.dart';
import 'crypto_state.dart';
import 'dht_connection_state.dart';
import 'profile_sharing/status.dart';
import 'utils.dart';

part 'coag_contact.g.dart';

// ignore: one_member_abstracts
abstract interface class BinarySerializable {
  Uint8List toBytes();
}

@JsonSerializable()
class CoagContact extends Equatable implements JsonEncodable {
  const CoagContact({
    required this.coagContactId,
    required this.name,
    required this.connectionCrypto,
    required this.myIdentity,
    required this.myIntroductionKeyPair,
    this.details,
    this.dhtConnection,
    this.theirIdentity,
    this.connectionAttestations = const [],
    this.systemContactId,
    this.addressLocations = const {},
    this.temporaryLocations = const {},
    this.comment = '',
    this.profileSharingStatus = const ProfileSharingStatus(),
    this.theirIntroductionKey,
    this.myPreviousIntroductionKeyPairs = const [],
    this.introductionsForThem = const [],
    this.introductionsByThem = const [],
    this.origin,
    this.verified = false,
  });

  /// Constructor that requires all fields to be explicitly provided
  const CoagContact.explicit({
    required this.coagContactId,
    required this.name,
    required this.dhtConnection,
    required this.connectionCrypto,
    required this.myIdentity,
    required this.myIntroductionKeyPair,
    required this.details,
    required this.theirIdentity,
    required this.connectionAttestations,
    required this.systemContactId,
    required this.addressLocations,
    required this.temporaryLocations,
    required this.comment,
    required this.profileSharingStatus,
    required this.theirIntroductionKey,
    required this.myPreviousIntroductionKeyPairs,
    required this.introductionsForThem,
    required this.introductionsByThem,
    required this.origin,
    required this.verified,
  });

  final String coagContactId;

  /// Their long lived typed identity key, used for example to derive a
  /// connection attestation for enabling others to discover shared contacts
  final PublicKey? theirIdentity;

  /// My long lived typed identity key pair, used for example to derive a
  /// connection attestation for enabling others to discover shared contacts
  final KeyPair myIdentity;

  /// All connection attestations they provide for shared contact discovery
  final List<String> connectionAttestations;

  /// Name given to the contact by the app user
  final String name;

  /// Associated system contact
  final String? systemContactId;

  /// Details shared by the contact
  final ContactDetails? details;

  /// Comment from the app user about the contact for personal reference
  final String comment;

  // This is a map from index to value instead of a list because only the ith
  // address could have a location
  final Map<String, ContactAddressLocation> addressLocations;
  final Map<String, ContactTemporaryLocation> temporaryLocations;

  /// DHT record info for sharing with this contact
  final DhtConnectionState? dhtConnection;

  /// Cryptographic keys for sharing with this contact
  final CryptoState connectionCrypto;

  /// Personalized selection of profile info that is shared with this contact
  final ProfileSharingStatus profileSharingStatus;

  /// Current public key the app user can hand to others when introducing them
  /// to this contact
  final PublicKey? theirIntroductionKey;

  /// Current key pair of which the app user has shared the public key with this
  /// contact to facilitate encrypted communication for introductions
  final KeyPair myIntroductionKeyPair;

  /// List of app user's previous key pairs of which they have shared the public
  /// key with this contact
  final List<KeyPair> myPreviousIntroductionKeyPairs;

  /// Introductions the app user proposed them
  final List<ContactIntroduction> introductionsForThem;

  /// Introductions this contact proposed the app user
  final List<ContactIntroduction> introductionsByThem;

  /// Origin information, like batch DHT key + subkey index
  final String? origin;

  final bool verified;

  factory CoagContact.fromJson(Map<String, dynamic> json) {
    // This is just a hack because somehow the pictures list representation
    // screws with the autogenerated fromJson
    if (json['system_contact'] != null &&
        json['system_contact']['thumbnail'] != null) {
      json['system_contact']['thumbnail'] = null;
    }
    if (json['system_contact'] != null &&
        json['system_contact']['photo'] != null) {
      json['system_contact']['photo'] = null;
    }
    return _$CoagContactFromJson(
      migrateContactAddressLocationFromIntToLabelIndexing(json),
    );
  }

  Map<String, dynamic> toJson() {
    final json = _$CoagContactToJson(this);
    // This is just a hack because somehow the pictures list representation
    // screws with the autogenerated fromJson
    if (json['system_contact'] != null &&
        json['system_contact']['thumbnail'] != null) {
      json['system_contact']['thumbnail'] = null;
    }
    if (json['system_contact'] != null &&
        json['system_contact']['photo'] != null) {
      json['system_contact']['photo'] = null;
    }
    return json;
  }

  CoagContact copyWith({
    String? coagContactId,
    String? name,
    String? comment,
    String? systemContactId,
    ContactDetails? details,
    PublicKey? theirIdentity,
    KeyPair? myIdentity,
    List<String>? connectionAttestations,
    Map<String, ContactAddressLocation>? addressLocations,
    Map<String, ContactTemporaryLocation>? temporaryLocations,
    DhtConnectionState? dhtConnection,
    CryptoState? connectionCrypto,
    ProfileSharingStatus? profileSharingStatus,
    PublicKey? theirIntroductionKey,
    KeyPair? myIntroductionKeyPair,
    List<KeyPair>? myPreviousIntroductionKeyPairs,
    List<ContactIntroduction>? introductionsByThem,
    List<ContactIntroduction>? introductionsForThem,
    String? origin,
    bool? verified,
  }) => CoagContact(
    coagContactId: coagContactId ?? this.coagContactId,
    details: (details ?? this.details)?.copyWith(),
    systemContactId: systemContactId ?? this.systemContactId,
    addressLocations: {...addressLocations ?? this.addressLocations},
    temporaryLocations: {...temporaryLocations ?? this.temporaryLocations},
    dhtConnection: dhtConnection ?? this.dhtConnection,
    connectionCrypto: connectionCrypto ?? this.connectionCrypto,
    profileSharingStatus: profileSharingStatus ?? this.profileSharingStatus,
    name: name ?? this.name,
    theirIdentity: theirIdentity ?? this.theirIdentity,
    myIdentity: myIdentity ?? this.myIdentity,
    connectionAttestations: [
      ...connectionAttestations ?? this.connectionAttestations,
    ],
    comment: comment ?? this.comment,
    theirIntroductionKey: theirIntroductionKey ?? this.theirIntroductionKey,
    myIntroductionKeyPair: myIntroductionKeyPair ?? this.myIntroductionKeyPair,
    myPreviousIntroductionKeyPairs: [
      ...myPreviousIntroductionKeyPairs ?? this.myPreviousIntroductionKeyPairs,
    ],
    introductionsByThem: [...introductionsByThem ?? this.introductionsByThem],
    introductionsForThem: [
      ...introductionsForThem ?? this.introductionsForThem,
    ],
    origin: origin ?? this.origin,
    verified: verified ?? this.verified,
  );

  @override
  List<Object?> get props => [
    coagContactId,
    details,
    systemContactId,
    dhtConnection,
    connectionCrypto,
    profileSharingStatus,
    theirIdentity,
    myIdentity,
    connectionAttestations,
    name,
    comment,
    addressLocations,
    temporaryLocations,
    theirIntroductionKey,
    myIntroductionKeyPair,
    myPreviousIntroductionKeyPairs,
    introductionsByThem,
    introductionsForThem,
    origin,
    verified,
  ];
}

/// Help with the switch from Map<int, ContactAddressLocation> to
/// Map<String, ContactAddressLocation>
Map<String, dynamic> migrateContactAddressLocationFromIntToLabelIndexing(
  Map<String, dynamic> json,
) {
  final _json = {...json};
  if (_json.containsKey('address_locations')) {
    final addressLocations = _json['address_locations'] as Map<String, dynamic>;
    _json['address_locations'] = Map<String, dynamic>.from(
      addressLocations.map(
        (key, address) => MapEntry(address['name'] ?? key, address),
      ),
    );
  }
  return _json;
}

Future<CoagContact> contactMigrateFromJson(String json) async =>
    CoagContact.fromJson(jsonDecode(json) as Map<String, dynamic>);
